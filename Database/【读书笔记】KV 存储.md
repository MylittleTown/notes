*（该笔记是基于一篇博客https://blog.csdn.net/u012414189/article/details/84251171）*

存储介质提供一个存储体，结合存储服务形成一个存储系统，最常见的存储系统就是文件系统，以文件的方式来在存储体山管理数据。同时也可以使用数据库，以数据库操作的形式来管理数据。同时还存在一种自定义的方法，一般称为NoSQL 的方式，即键值存储系统，来直接对存储体进行管理。



### 键值对存储的概述

键值对存储是数据库最简单的组织形式，是抽象出来的最简单的模型。基本上所有的编程语言都带有应用在内存中的键值对存储。C++STL 的映射容器（map container）和Java 的HashMap 以及Python 的字典类型都是键值对存储。

键值对存储通常都有如下接口：

```python
# Get(key): 获取之前存储于某标识符"key" 之下的一些数据，或者"key"下没有数据时报错
# Set(key, value): 将"value"存储到存储空间中某标识符"key"下，使得我们可以通过调用相同的"key"来访问它。如果"key"下已经有了一些数据，旧的数据将被替换
# Delete(key): 删除存储在"key"下的数据
```

大部分底层实现都是使用哈希表或者某种自平衡树（例如B-树或者红黑树）。有时候数据太大而装不进内存，或者必须维持数据谨防系统因为未知原因而崩溃。在这些情况下，就必须使用到文件系统。

键值对存储是NoSQL 的一部分，NoSQL 将所有不使用基于关系型数据库概念的数据库系统组合在一起。维基百科上的NoSQL 词条很好的总结了这些数据库的特征。

- 不使用SQL 查询语言
- 可以不全面支持ACID（原子性，一致性，隔离性，持久性）
- 可提供分布式，容错强的结构

### 键值对存储和关系型数据库

不像关系型数据库，键值对存储不需要了解值中的数据，也没有像MySQL 或者PostgreSQL 中那样的任何结构。这同时表示像SQL 那样用WHERE语句或者通过任何形式的过滤来请求数据中的一部分是无法做到的。

如果你不知道去哪找，你必须遍历所有的键，获取它们对应的值，应用某种你需要的过滤，然后保留你想要的东西。这将会需要大量的运算，**也即表示只有当键已知的时候才能体现出最佳的性能**，否则键值对存储将无法胜任（注意：一些键值对存储能够存储结构化的数据并有字段索引）

因此，即使键值对存储在访问速度上经常比关系型数据库系统性能要好数个数量级，但对键已知的需求也限制着其应用。

键：存的值的编号

值：要存放的数据

在键值对存储模式中，数据表*（Q: 键值对存储模式中数据的存放还会以表这种二维形式存储吗？）*中的每个实际行都具有行键（Key）和数值（Value）两个基本内容。值可以看作是一个单一的存储区域，可能是任何数据类型*（Q: 这里的数据类型应该指的是基本数据类型和图像，结构体等？还是仅代表基本数据类型？）*，甚至是数组。每个键都可能有不同的列名，不同键对应的值可能是完全不同的列。

值的设计考虑的是内存读取的时间和空间。例如，将频繁读取的值组合起来，用一个键名去读取，节省磁盘读取时间；即使对于属于同一个实体的信息（大型的数据结构，嵌套结构等），最好独立出其中读取频繁的属性，节省内存空间。

关系型数据库中，字段的验证规则是以键值对的形式定义的，其中键包含了验证规则作用的数据库字段名，而值则包含了所有施加于该字段的约束规则。

### 键值数据库概述

键值数据库是一种非关系数据库，它使用简单的键值方法来存储数据。键值数据库将数据存储为键值对集合，其中键作为唯一标识符。键值数据库是高度可分区的，并且允许以其他类型的数据库无法实现的规模进行水平扩展。

键值模式，列式存储模式和文档存储模式通常被称为面向聚合的数据模型。

### 键值数据库的特点

1. 简洁

   只涉及到增加和删除操作，不需要设计复杂的数据模型，也不需要为每个属性指定数据类型。动态添加时不需要修改原有数据库的定义。

2. 高速

   将数据保存在内存中，在RAM中读取和写入速度要快很多，当然也可以选择持久化。因为是存在内存中，有时需要释放类存储新的数据，最常用的算法：LRU（Least Recently Used，最久未使用算法）

3. 易于缩放

   根据系统负载量，随时添加或删除服务器

### 键值对数据库的两种读写方式

1. 面向磁盘的读写方式

   通常情况下，NoSQL 系统中都存储着海量的数据，且无法全部维持在内存中，所以一般都采用面向磁盘的读写方式。

   通常，当写入数据时候，数据会首先被写入到一个内存结构中，系统返回写入成功，当内存中的数据达到指定大小或者存放超过指定时限时，会被批量写入磁盘，当需要读取数据时，首先访问内存结构，如果未命中则需要访问磁盘上的实例化文件，当系统发生意外宕机时，内存结构中的数据将丢失。因此一般采用日志的方式来帮助数据进行恢复。为了进一步提高写入效率和并发能力，许多系统都采用了Append 方式，即将修改和删除操作都追加到文件末尾，而读数据时利用时间戳过滤掉旧信息，返回用户最新版本的数据。因此，数据库需要进行定期的数据合并，将过期的冗余数据删除。

2. 面向内存的读写方式

   内存数据库将所有的数据存放在内存中。每次访问记录时，无需将数据从磁盘中读到内存中，避免磁盘操作造成的延迟。随着存储技术的迅猛发展，单台机器的内存容量不断增长。使得将所有数据存在内存中成为可能。磁盘读写的操作不再是性能瓶颈，数据库系统由IO 受限转向CPU 受限。

### KV Store （键值对存储模式）的应用场景

如果没有索引的需求，使用类似堆表的存储，因为不需要根据rowid 查询row，那确实不需要KV Store，分布式场景下也不需要，所有的查询都遍历全表就行了，并不影响关系模型。

在OLTP 场景下，索引是强需求，无论单实例数据库还是分布式数据库都需要有key -> value 的查询能力，比如innodb 的主键聚簇索引引擎，需要实现主键到row 映射的KV Store；而Oracle 这种堆表引擎，既需要索引列到rowid 映射的KV Store，也需要rowid 到row 物理映射的特殊KV Store。

所以，只要是对于有索引需求的场景，无论单实例还是分布式数据库，都需要KV Store。

