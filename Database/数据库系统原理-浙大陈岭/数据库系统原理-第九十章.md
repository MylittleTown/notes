### 第一范式

如果某个域中元素被认为是不可分的，则这个域称为是原子的，非原子域的例子有：

- 复合属性：名字（集合）
- 多值属性：电话号码
- 复杂数据类型：面向对象的

如果关系模式R 的所有属性的域都是原子的，则R 称为属于第一范式（1NF）

非原子值存储复杂并易导致数据冗余，所以在设计关系数据库时所有关系都必须属于第一范式

那么，如何处理非原子值：

- 对于组合属性（复合属性）：让每个子属性本身成为一个属性
- 对于多值属性：为多值集合中的每个项创建一条元组

这里要注意，**原子性实际上是由域元素在数据库中如何被使用（语义）决定的**，而不是根据该属性的数据类型

### 模式分解

例如，可以将关系模式(A, B, C, D) 分解为(A, B) 和(B, C, D) ，或者(A, C, D) 和(A, B, D)，或(A, B, C) 和(C, D)，或(A, B)，(B, C) 和(C, D)，或(A, D) 和(B, C, D)

原模式R 的所有属性都必须出现在分解后的(R1, R2) 中，即R 为R1 和R2 的并

无损连接分解：对关系模式R 上的所有可能的关系r 

![image-20201228165636258](C:\Users\92486\AppData\Roaming\Typora\typora-user-images\image-20201228165636258.png)

模式分解的目标是：当原关系模式R 不是“好的”形式时，将它分解成模式集合{R1, R2, ..., Rn} 使得每个新的关系模式是“好的”形式，分解是无损连接分解。为了达成目标，理论基于**函数依赖**和**多值依赖**

### 函数依赖

设R 是一个关系模式，且有属性集a 包含于R，b 包含于R，将函数依赖表示为如下

![image-20201228172102476](C:\Users\92486\AppData\Roaming\Typora\typora-user-images\image-20201228172102476.png)

（这里的表示方法和含义借用了数学上的函数概念：自变量x 和因变量f(x)）

在R 上成立当且仅当对任意合法关系r(R)，若r 的任意两条元组r1 和r2 在属性集a 上的值相同，则它们在属性集b 上的值也相同（换句话说，若a 的属性值确定了，则b 的属性值也唯一确定）。即

![image-20201228172355331](C:\Users\92486\AppData\Roaming\Typora\typora-user-images\image-20201228172355331.png)

我们将这种推导称为“函数b依赖于a，a 函数决定b”

根据上述的例子得到的关于“函数依赖”的定义，函数依赖是一种完整性约束，表示特定的属性值之间的关系，可以用来判断模式规范化和建议改进

函数依赖是码概念的推广，K 是关系模式R 的超码当且仅当R 函数依赖于K，或者说K 函数决定R，K 是R 的候选码当且仅当K 函数决定R 且不存在关系模式（属性集）K 的真子集a，使得a 函数决定R

我们常用函数依赖来检查关系（在数据库中也称为“表”）在给定函数依赖之下是否合法；也用函数依赖来对合法关系集合（我们通常在数据库概念中将关系集合称为“关系模式”，关系模式下的关系我们可以记为r(R)）指定约束，特别要注意的是，我们容易判别一个关系r 是否满足给定的依赖集，但不易判别依赖集是否在关系模式（关系集合）R 上成立，不能仅由某个关系r 推断出依赖集在关系模式R 上成立，R 上的函数依赖是否成立，通常由定义R 的语义决定。

被所有关系实例都满足的函数依赖称为平凡的，例如(ID, name) 函数决定ID，也有ID 函数决定ID，这时我们都称这些函数依赖是平凡的；一般的，若b 包含于a，则b 函数依赖a，这个函数依赖是平凡的。

### 函数依赖集的闭包

定义：给定函数依赖集F，存在其他函数依赖被F 逻辑蕴含，例如如果B 函数依赖A 且C 函数依赖B，则可推出C 函数依赖A，那么"A 函数决定C" 就被函数依赖集“B 函数依赖A 且C 函数依赖B” 逻辑蕴含。

被函数依赖集F 逻辑蕴含的全体函数依赖的集合称为F 的闭包，函数依赖集F 也可以是自身的闭包。

可以用Armstrong 公理来推导函数依赖集F 的闭包

![image-20201228194301141](C:\Users\92486\AppData\Roaming\Typora\typora-user-images\image-20201228194301141.png)

Armstrong 公理的补充定律

![image-20201228194559432](C:\Users\92486\AppData\Roaming\Typora\typora-user-images\image-20201228194559432.png)

以上规则都可以从Armstrong 公理推导出

计算函数依赖集F 的闭包的流程介绍

![image-20201228194832492](C:\Users\92486\AppData\Roaming\Typora\typora-user-images\image-20201228194832492.png)

### 属性集的闭包

通常我们在判断属性集合a 是否为超码时有两种方法：

- 一种方法是计算属性集合a 相关的函数依赖集F 的闭包，在闭包中找到所有属性集bi 函数依赖于a，当{b1b2...} = R 时我们认为属性集合a 为该实体集的超码，但是这么做开销很大，因为可能函数依赖集F 的闭包很大
- 另一种方法是计算a 的闭包

定义：给定一个属性集a，在函数依赖集F 下由a 函数决定的所有属性的集合为F 下的a 的闭包

计算属性集a 的闭包的流程

![image-20201228195546976](C:\Users\92486\AppData\Roaming\Typora\typora-user-images\image-20201228195546976.png)

这里的beta, gama 都是属性集合，并且很明显，结果集result 中的属性顺序没有影响

通过这个流程得到的关于属性集合a 的闭包，将有助于我们通过超码判断候选码，下面是判断候选码的过程（属性集合m 是候选码吗？）

- m 是超码吗？

  换句话就是“m 是否函数决定关系模式R？”，如果m 的闭包包含（注意，闭包一定不小于属性的并集）关系模式R，则属性集合m 是超码

- 存在属性集合m 的子集是超码吗？

  这个地方需要遍历属性集合m 的所有子集，判断其子集的闭包是否包含关系模式R，一旦有一个成立，则存在属性集合m 的子集是超码

- 如果第二步中不存在子集是超码，我们就可以判断属性集合m 是候选码

### 属性闭包的用法

- 测试超码

  为检测属性集合alpha 是否超码，可计算其闭包并检查是否包含关系模式R 的所有属性

- 测试函数依赖

  为检测beta 是否函数依赖alpha，只需要检查beta 是否包含于alpha 的闭包

- 计算函数依赖集F 的闭包

  对于每个gama 包含于关系模式R，计算gama 的闭包，对于每个包含于gama 的闭包的属性子集S，推导出gama 函数决定S 