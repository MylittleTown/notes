### 什么是关系模型？

- 关系数据库基于关系模型，是一个或者多个关系组成的集合
- 关系通俗来讲就是表（由行和列构成）
- 关系模型的主要优点是其简单的数据表示，易于表示复杂的查询
- SQL 语言是最广泛使用的语言，用于创建，操纵和查询关系数据库，而关系模型是其基础

### 关系示例

![关系示例](https://raw.githubusercontent.com/MylittleTown/notes/master/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%99%E5%A4%A7%E9%99%88%E5%B2%AD/Related_images/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png)

联系：一些实体之间的关联

关系：是一种数学概念，指的是表

实体集和联系集（E - R） == 真实的世界

关系 - 表，元组 - 行 == 机器的世界

### 关系基本结构

一般地，给出集合D1, D2, ..., Dn（Di = aij | j = 1...k），关系r 是：D1xD2x...xDn的子集，即一系列Dj 域的笛卡尔积，因而关系是一组n 元组（a1j, a2j, ..., anj）的集合，其中每个aij 属于Di

例如：*（Q: 这里我觉得写成“关系： 导师 - 专业 - 学生” 会误解成“关系指的是字段或者属性的集合”，由上一节中“关系是一种数学概念，是表”的解释来看，关系应该表示为行和列的二维数组）*

![关系结构示例](https://raw.githubusercontent.com/MylittleTown/notes/master/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%99%E5%A4%A7%E9%99%88%E5%B2%AD/Related_images/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png)

### 笛卡尔积示例

![笛卡尔积结果示例](https://raw.githubusercontent.com/MylittleTown/notes/master/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%99%E5%A4%A7%E9%99%88%E5%B2%AD/Related_images/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%BB%93%E6%9E%9C%E7%A4%BA%E4%BE%8B.png)

### 属性类型

- 关系的每个属性都有一个名称
- 域：每个属性的取值集合称为属性的域
- 属性值必须是原子的，即不可分割的（1NF，第一范式），例如多值属性值和复合属性值不是原子的。联系电话与人存在一对多的映射，是多值属性；人的姓名由于可以细分为姓氏（last name）和名（first name），是复合属性
- 特殊值null 是每一个域的成员，空值给数据库访问和更新带来很多困难，因此尽量避免使用空值

### 关系的概念

- 关系涉及两个概念：关系模式和关系实例
- 关系模式描述关系的结构：存储结构，约束等。例如Instructor-schema = (ID: string, name: string, dept_name: string, salary: int) 或者Instructor-schema = (ID, name, dept_name, salary)
- 关系实例表示一个关系的特定实例，也就是所包含的一组特定的行。将模式类比为“类型”，实例就类比为“变量值”
- 关系，关系模式，关系实例的区别：变量 == 关系；变量类型 == 关系模式；变量值 == 关系实例
- 关系的无序性：元组的顺序性是无关紧要的（元组能够以任意顺序存储），但一个关系中不能有重复的元组

### 码，键

- 使K 属于R，其中R 表示属性的集合
- 如果K 值能够在一个关系中唯一的标志一个元组，则K 是R 的超码，例如{instructor-ID, instructor-name} 和{instructor} 都是instructor 的超码
- 如果K 是最小超码，则K 是候选码，例如{instructor-ID} 是instructor 的候选码，因为它是一个超码，并且它的任意真子集都不能成为一个超码
- 如果K 是一个候选码，并由用户明确定义，则K 是一个主键，主键有且仅有一个。主键通常用下划线标记

### 外键

假设存在关系r 和s：r(<u>A</u>, B, C), s(<u>B</u>, D)，则在关系r 上的属性B 称作参照s 的外码，r 也称为外码依赖的参照关系，s 叫做外码被参照关系。参照关系中外码的值必须在被参照关系中实际存在或者为null（参照完整性，约束，防止插入不一致的数据），因为外码在被参照关系中为主码。

### 关系代数

在某种程度上是过程化语言，包括六个运算：

- Select 选择：

  执行选择时，选择条件必须是针对同一元组中的相应属性值代入进行比较。定义：= {t | t 属于r and p(t)}，其中p 为选择谓词，由逻辑连词与，或，非连接起来的公式，逻辑连词的运算对象可以是包含比较运算符的表达式（通过运算符对关系实例的某一属性值进行筛选）

- Project 投影：

  执行投影操作时，还需要保证结果作为关系实例的集合，不能存在重复的，所以需要删除重复的行，保留指定的k 列。投影的属性集合用“, ”连接表示属性显示的时候从左到右的顺序

- Union 并：

  定义：= {t | t 属于r or t 属于 s}，注意，等目，同元，即关系r 和s 的属性数目（关系模式）必须相同，且对任意i, r 的第i 个属性域和s 的第i 个属性域相同

- set difference 差（集合差）：

  定义：= {t | t 属于r and t 不属于s}，等目，同元，即他们的属性数目必须相同，且对任意i, r 的第i 个属性域和s 的第i 个属性域相同

- Cartesian product 笛卡尔积：

  定义：= {(t q) | t 属于r and q 属于s}，假设r(R) 的属性和s(S) 的属性没有交集，如果r(R) 的属性和s(S) 的属性有交集，那么必须重命名这些有交集的属性，例如r.A 和s.A 来表示两个关系模式中相同的属性A

- Rename 更名（重命名）：

  允许使用其他名字指代关系，例如px(E)，返回表达式E 的结果，并把名字x 赋给了它，这里表达式E 是关系代数表达式，假设是n 元的，则表达式px(A1, A2, ..., An)(E) （对关系E 及其属性都重命名）返回表达式E 的结果，并赋给它名字x，同时将属性重命名为A1, A2, ..., An，结果应该是关系

用户输入一个或者两个关系，并得到新的关系

附加运算（可以用之前的六个关系代数的操作表示）：

- Set intersection 交：

  定义：= {t | t 属于r and t 属于s}，前提条件是r 和s 同元，r 和s 的属性域是可兼容的。这里有一个等价，r 和s 的交等价于r - (r - s)

- Natural join 自然连接：

  例，R = （A, B, C, D）S = (E, B, D)，则关系r 和s 自然连接的结果模式为(A, B, C, D, E)，这里一定要注意各种名词，“关系”，“模式”，不要混淆。自然连接用之前的六个运算可以表示为如下：

  ![自然连接等价的基本运算表达式](https://raw.githubusercontent.com/MylittleTown/notes/master/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%99%E5%A4%A7%E9%99%88%E5%B2%AD/Related_images/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5%E7%AD%89%E4%BB%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F.png)

  也就是将两个关系做笛卡尔积并选择相同属性对应的值相等的关系实例（行）组成的关系（表），然后投影，取两个关系模式的属性并集合，消除重名属性。总结就是设关系r 和s 分别代表模式R 和S，那么r 和s 的自然连接是对模式R和S 做并运算后的关系。

  注：

  1. r, s 必须含有共同属性（名，域对应相同）
  2. 连接两个关系中同名属性值相等的元组
  3. 结果属性是二者属性集的并集，但消除重名属性

  theta 连接指的是连接条件可以由用户指定，是自然连接的扩展，自然连接的条件是同名属性相等

- Division  除：

  适用于包含了“对所有的”此类短语的查询，例如

  ![“除”运算示例](https://raw.githubusercontent.com/MylittleTown/notes/master/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%99%E5%A4%A7%E9%99%88%E5%B2%AD/Related_images/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E2%80%9C%E9%99%A4%E2%80%9D%E8%BF%90%E7%AE%97%E7%A4%BA%E4%BE%8B.png)

  设r 和s 分别代表模式R 和S 的关系，其中R = (A1, A2, ..., Am, B1, ..., Bn)，S = (B1, ..., Bn)，则除运算的结果代表模式R - S的关系，即(A1, A2, ..., Am)，定义：关系r 在模式R - S的投影，其结果中的元组t 与s 中所有元组的拼接被r 覆盖，即拼接结果必须要在关系r 中存在，进一步解释开头说的，关系r 的关系模式必须包含“所有”对应的关系s 的属性子集和商的属性集的并。

  即，若q 是r 和s 做除运算的结果，则满足q 与s 的笛卡尔积结果包含于关系r 

- Assignment 赋值：

  赋值运算可以使复杂的查询表达变得简单，通过赋值运算可以把查询表达为一个顺序程序，该程序包括：一系列赋值和一个其值被作为查询结果显示的表达式。对关系代数查询而言，赋值必须是赋给一个临时关系变量，该关系变量可以在后续的表达式中使用。

关系代数中的最大最小，逻辑上存在两两比较，所以可以考虑笛卡尔积

例如：找出银行中最大的账户余额

- 将account 关系重命名为d，用于笛卡尔积下重复属性的表示
- 找出由非最大余额构成的临时关系（表），考虑所有满足关系d 中存在值大于account 关系中balance 的属性值的某一行，由于笛卡尔积能够遍历关系account 和关系d 的所有组合类型，所以这次比较一定不会漏掉某个account 关系实例
- 找出最大余额，利用集合差

关系运算的优先级：

1. 投影
2. 选择
3. 笛卡尔积
4. 连接，除
5. 交
6. 并，差

### 扩展运算

- 广义投影：

  允许投影列表中使用算数函数来对投影操作进行扩展，对属性值进行一定的操作。

- 聚集函数（聚合函数）：

  聚合函数输入一个值集合，然后返回单一值作为结果，对值集合进行操作的函数包括：avg（平均值），min（最小值），max（最大值），sum（值的总和），count（值的数量）。一次运算操作可以对多个属性调用上述聚合函数求值并返回结果。

  ![聚集函数表示方法](https://raw.githubusercontent.com/MylittleTown/notes/master/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%99%E5%A4%A7%E9%99%88%E5%B2%AD/Related_images/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)

  其中：

  - E 是任意关系表达式
  - G1, G2, ..., Gn 是用于分组的一系列属性，也就是说，之后的聚集函数将会在分组中运算，并根据分组的属性拼接成新的关系（表），分组使用的属性集合将会在新的关系中保留
  - Fi 是聚集函数
  - Ai 是属性名

  聚集运算的结果是没有名称的，可以使用更名运算为其命名，也可以把重命名作为聚集运算的一部分，如下图中的B1, B2：

  ![聚集函数重命名](https://raw.githubusercontent.com/MylittleTown/notes/master/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%99%E5%A4%A7%E9%99%88%E5%B2%AD/Related_images/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D.png)

- 外连接：

  外连接运算是连接运算的扩展，可以处理缺失信息。保留一侧关系中所有与另一侧关系的任意元组都不匹配的元组，再把产生的元组**加到自然连接的结构上**（即新的关系将保留两侧关系的关系模式，并去除重复的属性名），对于那些由于对应不上而导致的信息缺失用空值表示。

  分为左外连接，右外连接，全外连接

### 空值

- 元组的某些属性值可以是空的

- null 表示未知值或值不存在

- 涉及空的任何算术表达式的结果为空，例如1 + null 结果为空值

- 聚集函数会忽略空值，也可以返回空值作为结果，通常遵循SQL 对空值的处理语义从而忽略空值

- 为了消除重复和分组，空值和其他值同等对待，有两种处理方式：一种方法是两个空值被认为是相同的（SQL 对空值的处理语义）；另一种方式是假设每个空值都是不同的

- 与空值的比较将返回一个特殊值：unknown，但不能用布尔值true 和false 来表示，举反例，不使用unknown 的前提下，当A 为空值时，not (A<5) 与A >= 5 的结果就会不相等

  使用特殊值unknown 的三值逻辑：

  - OR: (unknown or true) = true; (unknown or false) = unknown; (unknown or unknown) = unknown
  - AND: (true and unknown) = unknown; (false and unknown) = false; (unknown and unknown) = unknown
  - NOT: (not unknown) = unknown

### 数据库的修改

分为删除，插入，更新

1. 删除

   删除请求的表达与查询的表达非常相似，不同的是，前者不是要将找出的元组显示给用户，而是要将它们从数据库中除去。这样只能将元组整个的删除，而不能仅删除某些属性上的值。

   使用关系代数可以将删除表达为：r - E 并将结果赋值给r ，其中r 是关系，E 是关系代数查询（关系代数查询也是关系，赋值运算即可）

2. 插入

   为了将数据插入关系中，要么指明一个要插入的元组，要么写出一个查询，其结果是要插入的元组集合。使用关系代数表示为r 和E 的并，并将结果赋值给r ，其中r 是关系，E 是关系代数表达式，如果让E 是一个只包含元组的常量关系，插入就可以表达为向关系中插入单一元组

3. 更新

   某些情况下，可能只希望改变元组中的某个值，而不希望改变元组中的所有值，可以用广义投影运算来完成这个表达

   ![更新操作等价的广义投影运算](https://raw.githubusercontent.com/MylittleTown/notes/master/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%99%E5%A4%A7%E9%99%88%E5%B2%AD/Related_images/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%AD%89%E4%BB%B7%E7%9A%84%E5%B9%BF%E4%B9%89%E6%8A%95%E5%BD%B1%E8%BF%90%E7%AE%97.png)

   其中，当第i 个属性不被修改时，Fi 表示的是r 的第i 个属性；当第i 个属性将被修改时，Fi 表示的是一个只涉及常量和r 的属性的表达式，表达式给出了此属性的新值

在对关系做删除，插入或更新操作时，需要考虑多个关系之间存不存在外码参照关系，保证数据一致性

